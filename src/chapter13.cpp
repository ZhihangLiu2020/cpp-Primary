/*
类继承

    成员初始化列表
        定义派生类对象时，先调用基类构造函数，再调用派生类构造函数。析构时相反。
        在实现派生类构造函数时，可以指定要用的基类构造函数，如不指定，默认使用基类默认构造。
        指定方式：使用成员初始化列表 :father(a,b)
        son::son(const int &a,const int &b):father(a,b)
        {
            ...
        }

    is-a关系
        公有继承一般适用于，派生类对象本身也是基类对象 的情况。如 水果 基类，香蕉 派生类。称满足is-a关系。
        在准备派生出子类时，要先检查是否满足is-a关系。

    多态公有继承
        多态：同一个方法在基类和派生类中的行为是不同的。有两种方式可以实现：
            1.在派生类中重新定义基类的方法
            2.使用虚方法
            通常，如果要在派生类中重写基类的方法，则将基类中的方法声明为虚方法。这样程序将根据对象的类型来调用方法。同时，通常为基类声明一个虚析构。
            如何判断调用的是哪个方法？
            如果是通过对象调用方法，那么对象是什么类，就调用那个类中定义的方法。
            如果通过引用或指针来调用方法，
                1.没有使用virtual关键字：引用或指针是什么类，就调用那个类中定义的方法。
                2.使用类virtual关键字：引用或指针指向的对象是什么类，就调用那个类中定义的方法。

    静态联编和动态联编
        联编：将源代码中调用函数的步骤，解释为执行特定的函数代码块，叫做联编（binding）。
        静态联编：在编译过程中进行函数地址绑定。（函数地址早绑定）
        动态联编：运行时绑定函数地址。（函数地址晚绑定），这是使用虚函数的一大意义。
        默认联编方式为静态联编，因为它效率更高。编译器对虚方法使用动态联编。

        虚函数原理：（需要再理解理解，p523页）
            对于每个类，编译器都创建一个 虚函数地址表；
            对于每个对象，都增加一个隐藏成员，保存 虚函数地址表 的地址。（这个隐藏成员就是一个指针）

            构造函数不会继承给子类，因此不必声明为虚函数。
            析构函数需要声明为虚函数。
            友元不能是虚函数，因为友元不是类成员，只有类成员才能是虚函数。

    访问控制：protected
        protected和private的唯一区别，只有在继承的时候会表现出来，子类可以访问父类的protected成员。
        对于外部世界来说，protected和private相同；对于子类来说，protected和public相同。

    抽象基类
        纯虚函数：virtual int func() = 0; 此处的 =0 表名这是一个抽象类。
        包含纯虚函数的类，只用作基类，不能创建该类的对象。
        不能被继承的：
            构造函数
            析构函数
            赋值运算符
        
    需要注意的点：
        1.const的位置
            void star::show() const{...} 此处的const表示，该函数不会修改调用它的对象









*/