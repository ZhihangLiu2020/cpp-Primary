/*
内存模型和名称空间

单独编译
    为了使得程序方便修改和扩展，将程序分为三部分：
        1.头文件：包含结构声明和函数原型（声明）
            常常包含：
            函数原型
            #define或const定义的符号常量
            结构声明
            类声明
            模板声明
            内联函数
        2.源文件：包含与结构有关的函数的代码
        3.源文件：包含调用与结构相关的函数的代码
    包含自己的头文件时，应使用引号“test.h”，而不是尖括号<test.h>
    使用<>，编译器会去存储标准头文件的目录寻找，使用""，编译器会先找当前目录。

    在IDE中，不要将头文件加入项目列表中，也不要在源代码文件中包含其他源代码文件

    为了避免重复包含，可以使用：
    #ifndef
    ...
    #endif

存储持续性、作用域和链接性
    自动存储持续性：在函数定义中声明的变量（包括参数）。随函数的结束而离开内存。
        在函数中声明的变量和函数参数为自动存储，作用域为局部，无链接性。这些变量只在函数内部或包含它们的代码块中可见。
        随时可以使用{ }来新开一块代码块。
    静态存储持续性：在函数定义外定义的变量和用static定义的变量。在整个程序运行期间都存在内存。
        静态变量的数量在程序运行过程中不会变化，编译器分配固定内存来存储它们。
        如果没有显示初始化静态变量，编译器会把它们设置为0.
    动态存储持续性：使用new运算符分配的内存，直到delete将其释放才会离开内存。
    线程存储持续性（c++11）：使用thread_local声明的，其生命周期和线程一样长

    外部链接性：可在其他文件中访问
    内部链接性：只能在当前文件中访问
    无链接性：只能在当前函数或代码块中访问
    //三种链接性举例
    int global=100;//外部链接性
    static int infile=20;//内部链接性
    void function()
    {
        static int infunc=10;//无链接性
    }

    extern关键字：是引用声明
        c++有单定义规则：变量只能有一次定义，因此c++提供两种声明方式：
        1.定义声明（简称 定义）,它给变量分配空间
        int a;//a=0
        extern int b=1;//b=1
        2.引用声明，它不给变量分配空间，因为它引用已经定义过的变量。（使用extern关键字）
        extern int a;
        如果要在多个文件中使用外部变量，只需要在一个文件中定义它，但是在使用它的文件中用extern声明它。

        全局变量（外部变量）天然具有外部链接性，因此在不同的文件中，也不能声明2个相同名字的变量，而要使用static限定其中一个。

        cv限定符：
        1.const
            使用const定义符号常量。
            const定义的全局变量具有内部链接性，和static效果相同
                const int a=10;
                static int a=10;
        2.volatile
            改善编译器的优化能力
        mutable:
            使得const的变量可以被修改

    函数和链接性：
        所有函数存储持续性自动为静态的，默认情况下链接性为外部的。
        可以使用static关键字将函数链接性设置为内部的。
    语言链接性：
        链接程序要求每个不同的函数都有不同的符号名。c和c++编制符号名的方式不一样。可以用函数原型指出要使用的方式
        extern "C" void func(int);//use C protocol
        extern "C++" void func(int);//use C++ protocol

    动态分配：
        如果在函数中定义了：
        int *p = new int[10];
        那么该函数结束时，p就会消失，但是分配的内存不会消失，需要用delete释放。

名称空间：
    关于变量的三个概念：
    声明区域：为其声明所在的代码块
    潜在作用域：从声明点开始到声明区域的结尾。
    作用域：变量对程序而言可见的范围。

    变量并非在其潜在作用域的任何位置都是可见的，有可能被嵌套声明区域中的同名变量隐藏。
    int a=10;//a1
    {
        int a=5;//a2
        cout<<a;//5.这里输出的是a2
    }
    cout<<a;//10，这里是a1

    使用关键字 namespace 来定义名称空间：
    namespace jack{
        double p;
        void fetch();
        struct well{

        };
    }
    使用作用域解析符::来限定名称空间：
        jack::fetch();

    c++提供using声明和using编译指令来简化对名称空间的使用：
        1.using声明，使特定的标识符可用，后面便可省略 jack::，只写名字
            using jack::fetch();
            fetch()
        2.using编译指令，使所有的名称都可用
            using namespace jack;

*/

