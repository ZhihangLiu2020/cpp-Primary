/*
函数探幽

内联函数：其实是空间换时间的一种做法。
    和常规函数的区别是，编译器如何将他们组合到程序中。
    常规函数的调用方法是，执行到函数调用指令时，保存该指令地址，把函数参数拷贝到堆栈，执行函数代码，
    然后跳回到地址被保存的指令处。（类似于看文章时看了一眼脚注）来回跳跃和记录地址意味着需要开销。

    内联函数，是将函数代码代替函数调用，这样就无需跳跃来。但是如果有10个地方调用同一个内联函数，那么
    该程序会包含这个函数代码的10个副本。
    
    使用内联函数：
        在函数声明前加 inline
        在函数定义前加 inline

引用变量：&
    就是给变量起别名，主要用途是作函数形参，这样函数会使用原始数据，而不是其副本。
    必须在声明引用变量时进行初始化。

    左值：可被引用的数据对象。变量，数组元素，结构成员等。
    非左值：字面常量；包含多项的表达式

    为什么使用引用？
    不使用引用的话，会多一次复制。

    将类对象传递给函数时，通常使用引用。（包括string类对象）

默认参数：
    必须从右到左添加默认值，如果一个参数有默认值，那么它右边的所有参数都要有默认值。
    int chico(int n,int m=1, int j=2);

函数重载：
    定义一系列函数，他们完成相同的工作，但是使用不同的参数列表。
    关键就是参数列表，也称为 函数特征标（function signature）。
    如果参数个数或参数类型不同，就可以发生重载。是参数类型，不是函数返回值类型；
    单独只有返回值类型不同，参数完全相同，不能发生重载；返回值类型不同，参数也不同，可以重载。

    1.如果调用函数时，填写的参数没有匹配到定义的函数，编译器会尝试强制类型转换来完成调用；
    但如果转换后发现匹配到好几个重载，编译器会拒绝本次调用。
    2.编译器检查函数参数时，把类型引用和类型本身视为相同的参数，不能重载。
    3.函数定义时参数带有const，则调用时可以匹配const或非const参数。
      函数定义时参数不带const，则调用时只能匹配非const参数。
      若重载了2个版本（const和非const），则调用时会根据参数类型进行匹配。
      这是由于将非const值赋给const变量是合法的，但是反过来是非法的。

函数模板：
    将类型抽象化，使用泛型来定义函数。例如：
    template <typename AnyType>
    void swap(AnyType &a, AnyType &b)
    {
        AnyType temp;
        temp=a;
        a=b;
        b=temp;
    }
    AnyType这个可以换为任何名字，如T。typename可以用class代替

    模板也可以发生重载，一般是令参数个数不同。

    在代码中包含函数模板，并不会生产函数定义。编译器使用模板为特定类型生产函数定义时，得到的是模板实例。
    模板并非函数定义，但是模板实例是函数定义。

    模板也有局限性，假如传入的参数是自定义的类型（如结构体），那很多运算（>,<）就无法直接进行。
    一种方案是重载运算符，另一种方案是显示具体化。
    对于给定的函数名，可以有 非模版函数，显示具体化模板函数，模板函数。（匹配优先级依次降低）
    struct job{
        char name[40];
        double salary;
        int floor;
    };
    //非模板函数
    void swap(job &,job &);
    
    //显示具体化模板函数
    template<> void swap(job &,job &);

    //模板函数
    template<typename T>
    void swap(T &,T &);

    编译器选择函数版本的过程，叫做重载解析（overloading resolution）。
    1.创建候选函数列表（找到名字相同的函数和函数模板）
    2.使用候选函数创建 可行函数 列表（找到参数可以对应的函数和函数模板）
    3.确定是否有最佳可行函数，如有则调用，否则报错。
        确定最佳的顺序：
        1.完全匹配
        2.提升转换（char->int,float->double）
        3.标准转换（int->char,long->double）
        4.用户自定义转换

    c++11中新增 decltype 关键字：
        在模板中，有时候不知道x+y的结果是什么类型，就可以用decltype(x+y)来表示这种类型/
        decltype(x+y) z=x+y; //把z定义为x+y的类型

        但有时候decltype需要声明在x,y的前面，这就导致无法使用decltype推导x+y的类型，
        这时，使用auto关键字在前，把decltype（x+y）作为后置返回类型：
        auto h(int x,float y) -> decltype(x+y)
        {
            ...
            return x+y;
        }

*/